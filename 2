import { drawButtons, drawObstacleParameters, drawOutlines, drawObstacles, drawTools } from "../utils/draw.ts";
import { getButtonUnderMouse, getObstacleUnderMouse, getToolUnderMouse, handleLeftClick, handleMiddleClick, handleMouseMove, handleMouseUp } from "./handler.ts";
import { editorState as eS } from "./state.ts";

const canvas = document.getElementById("canvas") as HTMLCanvasElement;
const ctx = canvas.getContext("2d") as CanvasRenderingContext2D;
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

eS.tools.add({
    cords: { x: 0, y: 0 },
    size: { x: 40, y: 40 },
    label: "add",
});
eS.tools.add({
    cords: { x: 50, y: 0 },
    size: { x: 40, y: 40 },
    label: "delete",
});
eS.tools.add({
    cords: { x: 100, y: 0 },
    size: { x: 40, y: 40 },
    label: "resize",
});
eS.tools.add({
    cords: { x: 150, y: 0 },
    size: { x: 40, y: 40 },
    label: "drag",
});

document.addEventListener("mousemove", (e) => {
    handleMouseMove(e);
});

document.addEventListener("mouseup", () => {
    handleMouseUp();
});

document.addEventListener("mousedown", (e) => {
    switch (e.button) {
        case 0:
            handleLeftClick(e);
            break;
        case 1:
            handleMiddleClick();
            break;
    }
});

function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    eS.buttons.clear();

    drawObstacles(ctx);

    if (eS.selectedObstacle.value) {
        drawObstacleParameters(eS.selectedObstacle.value, ctx, eS.buttons);
    }

    if (!eS.selectedObstacle.value) {
        const hoveredObstacle = getObstacleUnderMouse();
        if (hoveredObstacle) drawOutlines(hoveredObstacle, ctx);
    }

    if (eS.buttons.size > 0) {
        drawButtons(ctx);
    }

    drawTools(ctx);

    if (eS.drag.value) {
        canvas.style.cursor = "grabbing";
    } else if (getToolUnderMouse()) {
        canvas.style.cursor = "pointer";
    } else if (getButtonUnderMouse()) {
        canvas.style.cursor = "pointer";
    } else {
        canvas.style.cursor = "default";
    }

    requestAnimationFrame(gameLoop);
}

gameLoop();
